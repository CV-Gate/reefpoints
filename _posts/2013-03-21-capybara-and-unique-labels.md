---
layout: post
title: "Fixing Capybara 2.0 and Labels"
comments: true
author: "Brian Cardarella"
twitter: bcardarella
github: bcardarella
category: ember
social: true
summary: "Capybara is broken, they refused to fix. Here is the monkey patch"
published: true
---

I love Capybara, it makes integration testing a breeze. However, one of
the decisions made for Capybara 2.0 confuses an annoys me. In Capybara
1.x you could do the following:

{% highlight ruby %}
fill_in 'Password', :with => '123456'
fill_in 'Password confirmation', :with => '123456'
{% endhighlight %}

And everything worked. In Capybara 2.0 this does not work. Capybara will
notice two labels that contain 'Password' and complain about an
ambiguous locator. The suggested work around is to attach meta data to
the input element and use that for the selector. There are two reasons
why I don't like this. First, I am doing Ember development now and I
have no control of the ID, it is generated by the framework. Second, I
believe that the integration test should be recreating the steps (as
much as possible) as if a user were actually using the app. Something
like:

{% highlight ruby %}
fill_in '[data-name="password"]', :with => '123456'
fill_in '[data-name="password_confirmation"]', :with => '123456'
{% endhighlight %}

Doesn't sit right with me. So, to fix this problem simply add the
following code into your `test_helper.rb`

{% highlight ruby %}
module XPath::HTML
  protected

  def locate_field(xpath, locator)
    locate_field = xpath[attr(:id).equals(locator) | attr(:name).equals(locator) | attr(:placeholder).equals(locator) | attr(:id).equals(anywhere(:label)[string.n.equals(locator)].attr(:for))]
    locate_field += descendant(:label)[string.n.contains(locator)].descendant(xpath)
    locate_field[~attr(:disabled)]
  end
end
{% endhighlight %}

And you should be all set!
